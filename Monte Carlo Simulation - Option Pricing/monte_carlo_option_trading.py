# -*- coding: utf-8 -*-
"""Monte Carlo - Option Trading

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EqVNTNYACSskdIj4may7dJIL7cgefzJI

### Monte Carlo Option Pricing Model

This notebook implements a Monte Carlo simulation to estimate the theoretical price of a **European call option**.

**What the code does:**

1.  **Fetches Stock Data:** It uses the `yfinance` library to download historical stock price data for a given ticker.
2.  **Estimates Volatility:** It calculates the historical annualized volatility of the stock's returns. Volatility is a key input in option pricing models, representing the degree of price fluctuations.
3.  **Runs Monte Carlo Simulation:** It simulates many possible future price paths of the underlying stock using a geometric Brownian motion model.
4.  **Calculates Option Payoffs:** For each simulated path, it determines the payoff of the call option at expiry (the difference between the stock price and the strike price, if positive).
5.  **Discounts Payoffs:** It discounts the average of these payoffs back to the present to get the estimated theoretical price of the option (the "MC Call Price").
6.  **Evaluates Entry:** It compares the calculated MC Price to the actual market premium of the option to suggest a potential trading decision (ENTER, MAYBE, or SKIP) based on a specified edge threshold.
7.  **Summarizes and Plots:** It presents the results in a table and visualizes the distribution of simulated terminal stock prices.

**What is a European Call Option?**

A **call option** is a contract that gives the buyer the right, but not the obligation, to buy an underlying asset (like a stock) at a specific price (the **strike price**) on or before a certain date (the **expiry date**).

A **European call option** is a specific type of call option where the buyer can **only** exercise their right to buy the underlying asset **on the expiry date**. This is different from an American option, which can be exercised at any time up to and including the expiry date.
"""

!pip install yfinance numpy pandas matplotlib scikit-learn

import math
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf

def get_latest_close(ticker: str) -> float:
    """Fetch the most recent available daily close."""
    hist = yf.Ticker(ticker).history(period="10d", interval="1d", auto_adjust=False)
    if hist.empty:
        raise ValueError(f"No price history returned for {ticker}.")
    return float(hist["Close"].dropna().iloc[-1])

def estimate_sigma_annualized(ticker: str, lookback_years: int = 3) -> float:
    """Annualized vol from daily log returns over the lookback window."""
    end = datetime.now()
    start = end - timedelta(days=365 * lookback_years + 10)
    df = yf.download(
        ticker,
        start=start.strftime("%Y-%m-%d"),
        end=end.strftime("%Y-%m-%d"),
        progress=False,
        auto_adjust=False,
    )
    if df.empty or "Close" not in df.columns:
        raise ValueError(f"Could not download enough data for {ticker}.")
    close = df["Close"].dropna()
    rets = np.log(close / close.shift(1)).dropna()
    sigma_daily = np.std(rets, ddof=1)
    sigma_annual = sigma_daily * math.sqrt(252.0)
    return float(sigma_annual)

def monte_carlo_call_price(
    S0: float, K: float, T: float, r: float, sigma: float,
    sims: int = 50_000, steps: int = 126, seed: int | None = None
):
    """
    Risk-neutral GBM Monte Carlo for a European call.
    Returns dict with price, stderr, 95% CI, Prob(ITM), terminal prices, and payoffs.
    """
    if seed is not None:
        np.random.seed(seed)

    dt = T / steps
    drift = (r - 0.5 * sigma**2) * dt
    shock = sigma * math.sqrt(dt)

    Z = np.random.normal(size=(sims, steps))
    increments = drift + shock * Z
    log_ST = math.log(S0) + np.cumsum(increments, axis=1)[:, -1]
    ST = np.exp(log_ST)

    payoffs = np.maximum(ST - K, 0.0)
    disc = math.exp(-r * T)
    price_est = disc * np.mean(payoffs)
    stderr = disc * np.std(payoffs, ddof=1) / math.sqrt(sims)

    ci_low = price_est - 1.96 * stderr
    ci_high = price_est + 1.96 * stderr
    itm_prob = float(np.mean(ST > K))

    return {
        "price": float(price_est),
        "stderr": float(stderr),
        "ci": (float(ci_low), float(ci_high)),
        "itm_prob": itm_prob,
        "terminal_prices": ST,
        "payoffs": payoffs,
        "disc": disc
    }

def evaluate_entry(
    mc_result: dict, K: float, premium: float | None, r: float, T: float,
    edge_threshold: float = 0.05
):
    """
    Compute EV and entry signal given market premium.
    - ENTER if MC price > premium * (1 + edge_threshold)
    - MAYBE if premium < MC price <= premium*(1+edge_threshold)
    - SKIP if MC price <= premium
    """
    price = mc_result["price"]
    ST = mc_result["terminal_prices"]

    if premium is None:
        return {
            "expected_value": None,
            "profit_prob": None,
            "profit_prob_finance": None,
            "breakeven_underlying": None,
            "signal": "NEEDS_PREMIUM",
            "rationale": "Provide the option premium to compute edge and a decision."
        }

    # Simple profit at expiry: payoff - premium > 0  => ST > K + premium
    profit_prob_simple = float(np.mean(ST > (K + premium)))
    # Including opportunity cost: ST > K + premium * e^{rT}
    profit_prob_finance = float(np.mean(ST > (K + premium * math.exp(r * T))))

    expected_payoff = float(np.mean(mc_result["payoffs"]))
    expected_value = mc_result["disc"] * expected_payoff - premium

    if price > premium * (1 + edge_threshold):
        signal = "ENTER"
        rationale = f"MC price (${price:.2f}) exceeds premium (${premium:.2f}) by > {int(edge_threshold*100)}%."
    elif price > premium:
        signal = "MAYBE"
        rationale = f"MC price (${price:.2f}) is only slightly above premium (${premium:.2f})."
    else:
        signal = "SKIP"
        rationale = f"MC price (${price:.2f}) is below premium (${premium:.2f}); negative edge."

    return {
        "expected_value": expected_value,
        "profit_prob": profit_prob_simple,
        "profit_prob_finance": profit_prob_finance,
        "breakeven_underlying": K + premium,
        "signal": signal,
        "rationale": rationale
    }

def summarize_results(
    ticker: str, S0: float, K: float, T: float, r: float, sigma: float,
    sims: int, steps: int, mc_result: dict, entry: dict | None
) -> pd.DataFrame:
    rows = [
        ["Ticker", ticker],
        ["S0 (start price)", f"{S0:.4f}"],
        ["Strike (K)", f"{K:.4f}"],
        ["T (years)", f"{T:.4f}"],
        ["Risk-free r", f"{r:.4%}"],
        ["Vol (sigma, annual)", f"{sigma:.4%}"],
        ["Simulations", f"{sims}"],
        ["Steps", f"{steps}"],
        ["MC Call Price", f"${mc_result['price']:.4f}"],
        ["Std. Error", f"${mc_result['stderr']:.4f}"],
        ["95% CI", f"[${mc_result['ci'][0]:.4f}, ${mc_result['ci'][1]:.4f}]"],
        ["Prob(ITM at expiry)", f"{mc_result['itm_prob']:.2%}"],
    ]
    if entry is not None and entry["expected_value"] is not None:
        rows += [
            ["Expected Value (disc. payoff - premium)", f"${entry['expected_value']:.4f}"],
            ["Prob(Profit at expiry, simple)", f"{entry['profit_prob']:.2%}"],
            ["Prob(Profit incl. opp. cost)", f"{entry['profit_prob_finance']:.2%}"],
            ["Breakeven underlying (simple)", f"${entry['breakeven_underlying']:.4f}"],
            ["Decision", entry["signal"]],
            ["Rationale", entry["rationale"]],
        ]
    return pd.DataFrame(rows, columns=["Metric", "Value"])

def plot_terminal_distribution(ST: np.ndarray, ticker: str, T: float, K: float | None = None):
    plt.figure()
    plt.hist(ST, bins=100, alpha=0.8)
    plt.title(f"Terminal Price Distribution S_T ({ticker}, T={T}y)")
    plt.xlabel("S_T")
    plt.ylabel("Frequency")
    if K is not None:
        plt.axvline(K)  # vertical line at strike
    plt.tight_layout()
    plt.show()

def run_monte_carlo(
    ticker: str,
    strike: float,
    premium: float | None = None,
    T: float = 0.5,            # ~6 months
    r: float = 0.045,          # risk-free rate
    sims: int = 50_000,
    steps: int = 126,
    lookback_years: int = 3,   # for historical vol estimate
    S0: float | None = None,   # override start price (else use today's close)
    sigma: float | None = None,# override vol (e.g., IV as decimal)
    seed: int | None = None,
    plot: bool = True
):
    # Inputs
    if S0 is None:
        S0 = get_latest_close(ticker)
    if sigma is None:
        sigma = estimate_sigma_annualized(ticker, lookback_years)

    mc_result = monte_carlo_call_price(
        S0=S0, K=strike, T=T, r=r, sigma=sigma,
        sims=sims, steps=steps, seed=seed
    )
    entry = evaluate_entry(mc_result, K=strike, premium=premium, r=r, T=T)

    df = summarize_results(
        ticker=ticker, S0=S0, K=strike, T=T, r=r, sigma=sigma,
        sims=sims, steps=steps, mc_result=mc_result, entry=entry
    )
    display(df)

    if plot:
        plot_terminal_distribution(mc_result["terminal_prices"], ticker, T, strike)

    # Return raw results if you want to consume programmatically
    return {
        "inputs": dict(ticker=ticker, S0=S0, K=strike, T=T, r=r, sigma=sigma, sims=sims, steps=steps, premium=premium),
        "mc": mc_result,
        "entry": entry
    }

# ----------RUN ----------
##Uncomment this to test quickly:
##On the Premiums you can get them on platforms like Robinhood
##Just make sure its a Call, with the same maturity days as the T below
_ = run_monte_carlo("NVDA", strike=220, premium=7.45, T=0.5, sims=100_000, seed=42)