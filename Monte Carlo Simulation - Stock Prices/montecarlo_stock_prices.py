# -*- coding: utf-8 -*-
"""MonteCarlo_Stock_Prices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YPgUQsEZXrddJfAjQz5bLfQ9AZe8PhRA

# Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install --upgrade pandas-datareader
# %pip install yfinance

import yfinance as yf
import pandas_datareader.data as web
import pandas as pd
import datetime as dt
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import style

import scipy.stats
import datetime as dt
### For figures
import plotly.express as px
import plotly.figure_factory as ff

"""# Monte Carlo Simulation of a Stock

**You need to change 3 things**
1. Start Dates and End Dates - Line 2-3
2. Ticker Symbol - Line 6
3. Start Price date for your simulation - Line -24 (It needs to be 1 day before End date in Line 2-3)

## Set up stock price details
"""

#  Set the starting and ending period
start = dt.datetime(2023, 1, 1) ##We are setting the reason for using a certain Mean, we can only do that using past returns
end   = dt.datetime(2025, 7, 14)

# What's your company's ticker?
ticker = 'NVDA'

# Download your company's stock price data
price = yf.download(ticker, start, end, interval='1d')
# web.get_data_yahoo('BTC-USD', start, end, interval = 'm')

# Use the stock prices to calculate the stock returns
price['returns'] = price['Close'].pct_change()
returns = price.dropna()
# returns = pd.DataFrame(price['returns'].dropna())
# returns = price['returns'].dropna()


# Calculate stock mean daily return (mu) and daily standard deviation (sigma)
mu = returns['returns'].mean()
sigma = returns['returns'].std() ## Our epsilon uses the MU and Sigma

# Define what's the starting price of the stock
start_price = returns['Close'].loc['2025-7-11'] ## This is our Price zero (Po)

print(start_price)
# Define your investment horizon:
days = 90

"""## Calculate stock price paths

To do this, we have to set up some assumptions. Specifically, we have to assume that prices follow Geometric Brownian Motion (GBM)

If markets are efficient, historical prices (like previous stock prices) have no effect on future stock prices. This intuition is captured by a GBM process (or a random walk process). Here is what this process looks like in paper:

$ \frac{\Delta P}{P} = \mu \Delta t + \sigma*\tilde{\epsilon}*\Delta t $

$ P_{t+1} = P_t \times (1+\tilde{\epsilon})$

where $\tilde{\epsilon}$ is a shock process such that: $\tilde{\epsilon} \sim N(\mu, \sigma^2) $
"""

# Let's define the program
def random_walk(startprice):
  price = np.zeros(days)    # Use numpy to create a price vector filled with zeros
  shock = np.zeros(days)    # Use numpy to create a shock vector filled with zeros
  price[0] = startprice     # Set the initial price of the stock to startprice
  for i in range(1, days):  # Create the path of prices for (N=90?) days
    shock[i] = np.random.normal(loc=mu, scale=sigma)       # This is your shock on day i
    price[i] = max(0, price[i-1]*(1+shock[i]))        # This is your price on day i after the shock happens
  return price              # This is what the program will return to you (a vector of prices)
  ##Day 1 to Day is just the fomula written in notes. Random walk is defining a program that we want python to use
  ## Shock is the shock process that changes our prices, in this case it is the Episolon.
  ##For  every value of i that goes for the neext 1 to 90 days. I want you to create 90 iterations

"""## Run the Monte Carlo Simulation to see the paths!

**You need to change 1 thing**
1. Plot lable for the Random Walk on Line - 12 and 16
"""

import yfinance as yf
import datetime as dt
import numpy as np
import matplotlib.pyplot as plt

plt.style.use('default')                  # First, define the style (style comes first :P)

# Now run the Simulation and see the figure
plt.figure(figsize=(9,4))
for run in range(10):  # How many simulations do you want?
    MC_prices = random_walk(start_price.iloc[0])  # Pass the numerical value of start_price
    plt.plot(MC_prices)      # This part plots each path
# Come on let's make it look pretty
plt.axhline(y=start_price.iloc[0], color='r', linestyle='-') # Pass the numerical value of start_price
plt.title("90-day Monte Carlo simulation paths for stock prices {}".format(ticker))
plt.xlabel("Days after 2025-7-11")
plt.ylabel("Price")
plt.show()

"""## Monte Carlo Simulations: Probability distribution of stock price at day 90

Our goal in this case is to run the simulation 10,000 times (or more if you want) and get 10,000 different end-values for Apple's stock returns.

Don't try to plot 10,000 paths, it will look terrible!

**You need to change 2 things**
1. Your confidence Level on Line - 6 (Remember 95% CI is alpha 5%)
2. If you change the above then you need to change Line 22 and 26 too
"""

# Run the same thing as above, but now do it for 10,000 simulations (don't)
runs = 1000000                  # Determine the number of simulations
simulations = np.zeros(runs)  # Define a vector of zeros that will store final price
for run in range(runs):
    simulations[run] = random_walk(start_price.iloc[0])[days-1]       # Stores the final price of Apple on the hypothetical path f run(i) on the 90th day
q = np.percentile(simulations,1)       # This is the first percentile (the lowest one!) of the distribution of possible Apple prices after 90 days
# Make the figure look nice!
plt.figure(figsize=(9,4))
plt.hist(simulations, density=True, bins=100, histtype="stepfilled", alpha=0.5)
plt.title("Final price distribution for {a} after {b} days".format(a=ticker, b=days), weight="bold");
plt.axvline(x=q, linewidth=1, color='r')
# Access the numerical value of start_price using .iloc[0]
plt.axvline(x=start_price.iloc[0], linewidth=0.5, color='blue', alpha=0.5)  # Changed this line
plt.xlabel("Stock Price")

# Add more information to make it fancier
# Access the numerical value of start_price using .iloc[0] where needed
import matplotlib.pyplot as plt
import datetime as dt
plt.figtext(0.6, 0.8, "Generated on: {}".format(dt.date.today().strftime("%Y-%m-%d")))
plt.figtext(0.6, 0.7, "Start price: {:.0f}".format(start_price.iloc[0])) # Changed this line
plt.figtext(0.6, 0.62, "Mean final price: {:.0f}".format(simulations.mean()), color='black', weight='bold') # Changed this line
plt.figtext(0.6, 0.54, "VaR(99%) = ${:.0f} ".format(start_price.iloc[0] - q)) # Changed this line
plt.figtext(0.6, 0.47,  "(Prob of losing <= ${:.0f} is 99%)".format(start_price.iloc[0] - q)) # Changed this line
plt.figtext(0.6, 0.42, "(Prob of losing > ${:.0f} is 1%)".format(start_price.iloc[0] - q)) # Changed this line
# plt.figtext(0.17, 0.6, "<= 1%".format(q))
plt.figtext(0.13, 0.6, "Worst 1% price is ${:.0f}".format(q))
plt.axvline(x=q, linewidth=2, color="r")
plt.figtext(0.22, 0.2, "Today's Price")
plt.show()

# plt.rc('font', **font)

##This calculates 900k Prices but plots 10k prices, so the graph below has 10k prices

#Can do this with credit scores, prices